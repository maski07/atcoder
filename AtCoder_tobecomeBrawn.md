# AtCoder 茶色まで
## 製造メモ
JavaScript
``` JavaScript
// cp base abc214_b.js & code abc214_b.js

/** メモ **/
'use strict'
/**  */
var log = console.log;
function Main(input){
	
}
// Main(require("fs").readFileSync("/dev/stdin", "utf8").trim());
```

Python
``` Python
""" スニペット """
def get_int():	return int(input())
def get_ints():	return list(map(int, input().split()))
""" スニペット """
```
## AtCoder豆知識
・10^8 ~ 10^9までのループを超えるとTLE(実行時間オーバ)になる

## もう一回ときたい
abc214_c

## アルゴリズムを身に着ける上でのルール
OKの定義は、C以上の問題を0から自分で解けたこと  
勉強の際には、実際に自分でプログラムを書く  
その日の夜、土日に再復習  

## スケジュール
7/20:深さ優先探索、最小公倍数、最大公約数  
7/27:順列の全列挙、2nや3n通りの全列挙(bit演算)、累積和(一次元のみ)  
8/3:累積和(一次元のみ)、木の基本的な性質、配列の二分探索  
8/10:茶色問題をとく  
9/7  :茶色問題をとく(R300-500)
9/14 :茶色問題をとく(R400-600)
9/21 :メモ化再帰、幅優先探索 
9/30 :漸化式を使った簡単なDP、最短経路計算  
10/6 :約数計算を使った素数列挙、素因数分解を使った素数列挙
10/12:除算を除く四則演算のMOD計算、Union-Find木
10/19:緑色問題を解く(R700-1000)
10/26:緑色問題を解く(R700-1000)

## 全探索の種類
	・本当に全通り調べ上げる「全探索」  
		前述の問題の、計算回数 N4 回のアルゴリズムがそれです。  
	大体の場合、多重ループで解けます。  
	・工夫して探索の通り数を減らす「全探索」  
		例えば、前述の問題であれば、(a,b,c)(a,b,c) の組を全通り調べ上げるとします。(a,b,c)(a,b,c) の組が決まったら、後は 	Ad=M−Ka−Kb−KcAd=M−Ka−Kb−Kc であるような dd が存在するか調べれば良いです。予め長さ 108108 の bool 型配列を定義し、11 以上 108108 以下の各整数が存在するかどうかを最初に記録しておけば、高速に調べられます。
		大体の場合、多重ループで上手くいきます。
	・ビット全探索  
	・順列全探索  

難易度 小：アルゴリズム知ってたらとける(習得も簡単)  
難易度 中：2,3回練習したらとけるようになる  
難易度 大：  
(※)：初見では解けなかった問題  

### 再度ときたい問題
abc202_c :このアルゴリズムは面白かった。実務で使えそう。


## 使えるようになるべきアルゴリズム (茶色)
- [x] 1_深さ優先探索：難易度 中  
	類似：abc114  
- [x] 2_最大公約数(ユークリッドの互除法)：難易度 小  
	類似 : abc109_c  
- [x] 3_最小公倍数(2つの積を最小公約数で割ったらとける)：難易度 小  
	類似 : abc148_c  
- [x] 4_エラストテネスの篩を使った素数列挙：難易度 小  
- [x] 5_順列の全列挙(pythonのnext_permutationを使うと楽) (標準で順列を作る関数がある。なければGoogleで良い) 難易度：小  
	類似 : abc150_c  
- [x] 6_累積和(一次元のみ)：難易度：中    
	類似 : abc122_c(※)、abc037_c、abc154_d、abc084_d(未)、abc124_d(未)  
- [x] 7_2nや3n通りの全列挙(bit演算でも関数を使った列挙でも)：難易度：中  
	類似 : arc061_a(※)、abc079_c、abc104_c  
- [x] 木の基本的な性質(辺の数がN-1になる事とか二点間の道が必ず一つな事とか、基本的な事だけ)  
	類似 : AntP85~を読んで理解すればOK  
- [x] upper_boundを使った配列の二分探索  
- [x] lower_boundを使った配列の二分探索  
- [ ] 計算量を算出できるようになる 
- [ ] 数学力を身に着ける
	類似：[その他](https://qiita.com/fujioka_math/items/1e55062c58d45f837b10)
#### そのほか茶色レベルで出てきたアルゴリズム  
- [x] 工夫がいる問題  
	問題：abc134_c(累積max(でも解ける))、abc137_c(※)、abc175_c(※)  
- [ ] 配列でデータを保持し、計算量を定数にする
	問題：abc174_d(※)、hkkb2020_c(*)
- [ ] 素因数分解 ([試し割り法](https://ja.wikipedia.org/wiki/試し割り法))
- [ ] 条件を考え最適化する問題
	問題：abc175_c(※)
- [ ] 数学問題
	問題：abc177_c、abc178(包除原理)
- [ ] 数学問題 (三角関数)
	問題：
- [ ] 貪欲法
類似：abc173_d(※)
---------- これで茶色達成‼︎ (8月中に全て習得する)
#### 茶色までの道のり 参考サイト
[AtCoderProblems](https://kenkoooo.com/atcoder)
[AtCoderの問題を分類しました](https://qiita.com/KoyanagiHitoshi/items/32dc42d8c5ee75339e54)
[高校数学で解けるAtCoderのC問題まとめ](https://qiita.com/fujioka_math/items/1e55062c58d45f837b10)

### ここから緑色アルゴリズム (9月までに全て習得する)  
- [ ] 挑戦中！・幅優先探索  
- [ ] 挑戦中！・メモ化再帰(重複計算を避けて計算量を落とす)  
	類似問題：aging2020_C、abc173_c  
- [ ] ダイクストラ法を使った最短経路計算  
- [ ] 漸化式を使った簡単なDP(確率DPとか桁DPは必須じゃないです)  
- [ ] 約数計算を使った素数列挙  
- [ ] 素因数分解を使った素数列挙  
- [ ] 除算を除く四則演算のMOD計算  
- [ ] 挑戦中！・Union-Find木(なくても解けるけどあると簡単になる問題がかなり多い印象)  
	類似：Ant81 、abc177_d
#### そのほか緑色問題で出てきたアルゴリズム  
- [ ] 数学的問題(数列など)
	類似：abc174_c
---------- これで緑色達成‼︎  
もちろん全てが必須な訳ではないですが、これらが身についていると300点〜400点問題を解くのがかなり楽になるはずです。  

▪️ AtCoder URL  
https://atcoder.jp/contests/arc061/tasks/arc061_a  

## アルゴリズム集
#### 累積和(5_ CumulativeSum)
パターン1:文字列の任意範囲から特定文字列の数を数える方法  
	文字列の出現回数を記録したオブジェクトを生成し、右端-左端で算出する  
	実際に図でかくとわかりやすい  
パターン2:特定の数値を足していく方法  
	重複がある場合は、重複を計算しない  

#### 工夫がいる問題を解く時の考え方
・出力が何通りあるのかを考える  
・等式を作って、無駄を排除する  
・最初にアルゴリズムを考える

## メモ： mdファイルの見方(VSCODE)
mac : cmd + shif + V  
windows: ctrl + shift + V
#### mdファイルの記法
https://qiita.com/oreo/items/82183bfbaac69971917f

### Pythonの使い方集
``` Python 
for i,data enumerate(list) # 配列から、indexとdataを取得してfor文を回す
```
▪️ AtCoder 茶色まで
▪️ メモ
// Main(require("fs").readFileSync("/dev/stdin", "utf8"));

● 目標
10月までにAtCoder緑を達成する！！

● ルール
OKの定義は、C以上の問題を0から自分で解けたこと
勉強の際には、実際に自分でプログラムを書く
その日の夜、土日に再復習

● スケジュール
1週間で2~3つのアルゴリズムを習得する
7/20:深さ優先探索、最小公倍数、最大公約数
7/27:順列の全列挙、2nや3n通りの全列挙(bit演算)
8/3:累積和(一次元のみ)、木の基本的な性質、配列の二分探索
-- ここで茶色を達成

● AtCoderの問題の進め方
C問題が解けなければ配点が上がらないので、C問題を先に取り組む
Cが解けたら、A, Bをとく
解けたのが0でも配点は変わらない。時間を無駄にしない。

● 全探索の種類
	・本当に全通り調べ上げる「全探索」
		前述の問題の、計算回数 N4 回のアルゴリズムがそれです。
	大体の場合、多重ループで解けます。
	・工夫して探索の通り数を減らす「全探索」
		例えば、前述の問題であれば、(a,b,c)(a,b,c) の組を全通り調べ上げるとします。(a,b,c)(a,b,c) の組が決まったら、後は 	Ad=M−Ka−Kb−KcAd=M−Ka−Kb−Kc であるような dd が存在するか調べれば良いです。予め長さ 108108 の bool 型配列を定義し、11 以上 108108 以下の各整数が存在するかどうかを最初に記録しておけば、高速に調べられます。
		大体の場合、多重ループで上手くいきます。
	・ビット全探索
	・順列全探索

難易度 小：アルゴリズム知ってたらとける(習得も簡単)
難易度 中：2,3回練習したらとけるようになる(コツがある)
難易度 大：
(※)：初見では解けなかった問題
▪️ 使えるようになるべきアルゴリズム
○・深さ優先探索：難易度 中
	類似：abc114
○・最大公約数(ユークリッドの互除法)：難易度 小
	類似：abc109_c
○・最小公倍数(2つの積を最小公約数で割ったらとける)：難易度 小
	類似：abc148_c
○・エラストテネスの篩を使った素数列挙：難易度 小
○・順列の全列挙(pythonのnext_permutationを使うと楽) (標準で順列を作る関数がある。なければGoogleで良い) 難易度：小
	類似：abc150_c
△・累積和(一次元のみ)：難易度：中  
	類似：abc122_c(※)、abc134_c、abc084_d、abc124_d
・2nや3n通りの全列挙(bit演算でも関数を使った列挙でも)：難易度：中
・木の基本的な性質(辺の数がN-1になる事とか二点間の道が必ず一つな事とか、基本的な事だけ)
	類似：AntP85~を読んで理解すればOK
・upper_boundを使った配列の二分探索
・lower_boundを使った配列の二分探索
---------- これで茶色達成‼︎ (今月中に全て習得する)
挑戦中！・幅優先探索
挑戦中！・メモ化再帰(重複計算を避けて計算量を落とす)
	類似問題：aging2020_C、abc173_c
・ダイクストラ法を使った最短経路計算
・漸化式を使った簡単なDP(確率DPとか桁DPは必須じゃないです)
・約数計算を使った素数列挙
・素因数分解を使った素数列挙
・除算を除く四則演算のMOD計算
挑戦中！・Union-Find木(なくても解けるけどあると簡単になる問題がかなり多い印象)
	類似：Ant81
---------- これで緑色達成‼︎
もちろん全てが必須な訳ではないですが、これらが身についていると300点〜400点問題を解くのがかなり楽になるはずです。


▪️ AtCoder 茶色まで
● ルール
OKの定義は、C以上の問題を0から自分で解けたこと
勉強の際には、実際に自分でプログラムを書く
その日の夜、土日に再復習

● スケジュール
1週間で2~3つのアルゴリズムを習得する
7/20:深さ優先探索、最小公倍数、最大公約数
7/27:累積和(一次元のみ)、木の基本的な性質、配列の二分探索

● 全探索の種類
	・本当に全通り調べ上げる「全探索」
		前述の問題の、計算回数 N4 回のアルゴリズムがそれです。
	大体の場合、多重ループで解けます。
	・工夫して探索の通り数を減らす「全探索」
		例えば、前述の問題であれば、(a,b,c)(a,b,c) の組を全通り調べ上げるとします。(a,b,c)(a,b,c) の組が決まったら、後は 	Ad=M−Ka−Kb−KcAd=M−Ka−Kb−Kc であるような dd が存在するか調べれば良いです。予め長さ 108108 の bool 型配列を定義し、11 以上 108108 以下の各整数が存在するかどうかを最初に記録しておけば、高速に調べられます。
		大体の場合、多重ループで上手くいきます。
	・ビット全探索
	・順列全探索

▪️ 使えるようになるべきアルゴリズム
○・深さ優先探索：難易度 中
	類似：abc114
○・最大公約数(ユークリッドの互除法)：難易度 小
	類似：abc109_c
○・最小公倍数(2つの積を最小公約数で割ったらとける)：難易度 小
	類似：abc148_c
○・エラストテネスの篩を使った素数列挙：難易度 小
・順列の全列挙(next_permutationを使うと楽) → いまはここ！
・2nや3n通りの全列挙(bit演算でも関数を使った列挙でも)
・累積和(一次元のみ)
・木の基本的な性質(辺の数がN-1になる事とか二点間の道が必ず一つな事とか、基本的な事だけ)
・upper_bound,lower_boundを使った配列の二分探索
---------- これで茶色達成‼︎
挑戦中！・幅優先探索
・ダイクストラ法を使った最短経路計算
・漸化式を使った簡単なDP(確率DPとか桁DPは必須じゃないです)
挑戦中！・メモ化再帰(重複計算を避けて計算量を落とす)
	類似問題：aging2020_C、abc173_c
挑戦中！・約数計算や素因数分解を使った素数列挙
・除算を除く四則演算のMOD計算
挑戦中！・Union-Find木(なくても解けるけどあると簡単になる問題がかなり多い印象)
	類似：Ant81
---------- これで緑色達成‼︎
もちろん全てが必須な訳ではないですが、これらが身についていると300点〜400点問題を解くのがかなり楽になるはずです。

▪️ メモ
// Main(require("fs").readFileSync("/dev/stdin", "utf8"));
